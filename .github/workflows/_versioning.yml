name: Versioning and Push Module

on:
  workflow_call:
    outputs:
      version:
        description: "Generated version"
        value: ${{ jobs.version-and-push.outputs.version }}
      image_uri:
        description: "Pushed image URI"
        value: ${{ jobs.version-and-push.outputs.image_uri }}

permissions:
  contents: write
  packages: write

jobs:
  version-and-push:
    name: Version & Push to ECR
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: ${{ github.ref == 'refs/heads/production' && 'production' || github.ref == 'refs/heads/staging' && 'staging' || 'development' }}
    outputs:
      version: ${{ steps.version.outputs.new_version }}
      image_uri: ${{ steps.push.outputs.image_uri }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Analyze commit messages
        id: analyze-commits
        run: |
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          if [ -n "$LAST_TAG" ]; then
            COMMITS=$(git log ${LAST_TAG}..HEAD --oneline)
          else
            COMMITS=$(git log --oneline)
          fi

          BREAKING_CHANGES=$(echo "$COMMITS" | grep -i "BREAKING CHANGE\|!" | wc -l)
          FEATURES=$(echo "$COMMITS" | grep -E "^[a-f0-9]+ feat" | wc -l)
          FIXES=$(echo "$COMMITS" | grep -E "^[a-f0-9]+ fix" | wc -l)

          if [ "$BREAKING_CHANGES" -gt 0 ]; then
            SUGGESTED_BUMP="major"
          elif [ "$FEATURES" -gt 0 ]; then
            SUGGESTED_BUMP="minor"
          elif [ "$FIXES" -gt 0 ]; then
            SUGGESTED_BUMP="patch"
          else
            SUGGESTED_BUMP="patch"
          fi

          echo "suggested_bump=$SUGGESTED_BUMP" >> $GITHUB_OUTPUT

      - name: Calculate version
        id: version
        run: |
          if [ -f package.json ] && command -v jq >/dev/null 2>&1; then
            CURRENT_VERSION=$(jq -r '.version // "0.0.0"' package.json)
          else
            CURRENT_VERSION=$(git describe --tags --abbrev=0 2>/dev/null | sed 's/^v//' || echo "0.0.0")
          fi

          IFS='.' read -ra VERSION_PARTS <<< "$CURRENT_VERSION"
          MAJOR=${VERSION_PARTS[0]:-0}
          MINOR=${VERSION_PARTS[1]:-0}
          PATCH=${VERSION_PARTS[2]:-0}

          BUMP_TYPE="${{ steps.analyze-commits.outputs.suggested_bump }}"

          case "$BUMP_TYPE" in
            major)
              MAJOR=$((MAJOR + 1))
              MINOR=0
              PATCH=0
              ;;
            minor)
              MINOR=$((MINOR + 1))
              PATCH=0
              ;;
            patch)
              PATCH=$((PATCH + 1))
              ;;
          esac

          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT

      - name: Update package.json
        if: hashFiles('package.json') != ''
        run: |
          if command -v jq >/dev/null 2>&1; then
            jq --arg version "${{ steps.version.outputs.new_version }}" '.version = $version' package.json > package.json.tmp
            mv package.json.tmp package.json
          fi

      - name: Commit version changes
        if: hashFiles('package.json') != ''
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          git add package.json
          git commit -m "chore: bump version to ${{ steps.version.outputs.new_version }}" || echo "No changes to commit"

      - name: Create git tag
        run: |
          TAG_NAME="v${{ steps.version.outputs.new_version }}"
          git tag -a "$TAG_NAME" -m "Release $TAG_NAME"
          git push origin "$TAG_NAME"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Tag and push image to ECR
        id: push
        run: |
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY="${{ secrets.ECR_REPOSITORY_NAME }}"
          VERSION_TAG=${{ steps.version.outputs.new_version }}
          COMMIT_TAG=${{ github.sha }}

          aws ecr describe-repositories --repository-names $ECR_REPOSITORY 2>/dev/null || \
          aws ecr create-repository --repository-name $ECR_REPOSITORY

          docker tag cloudinsight-frontend:$COMMIT_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION_TAG
          docker tag cloudinsight-frontend:$COMMIT_TAG $ECR_REGISTRY/$ECR_REPOSITORY:latest

          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$VERSION_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest

          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$VERSION_TAG"
          echo "image_uri=$IMAGE_URI" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: v${{ steps.version.outputs.new_version }}
          release_name: Release v${{ steps.version.outputs.new_version }}
          body: |
            CloudInsight Frontend Release v${{ steps.version.outputs.new_version }}

            Container Image: ${{ steps.push.outputs.image_uri }}
            Commit: ${{ github.sha }}
          draft: false
          prerelease: false
